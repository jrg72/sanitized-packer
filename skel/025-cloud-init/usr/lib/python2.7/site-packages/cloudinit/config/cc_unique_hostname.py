# -*- encoding: utf-8 -*-

## generates a unique hostname for this instance and creates an A record in
## Route53.
## preserve_hostname is required to disable cc_set_hostname and cc_update_hostname.
## update_etc_hosts defaults to false, but will get in our way if set.
## instance IAM role must allow for creating and updating Route53 RRs.

## example config:
##   preserve_hostname: true
##   update_etc_hosts: false
##   unique_hostname:
##       route53_zone_id: <zone id>
##       role: web-server

from cloudinit.settings import PER_ALWAYS
from cloudinit import util
import StringIO
import re

import boto.ec2
import boto.route53
import subprocess

## run this on every boot, to ensure the IP address is in sync
frequency = PER_ALWAYS

hosts_entry_re = re.compile(r"""^(:+)?\d+""")


def handle(name, _cfg, _cloud, log, _args):
    cfg = _cfg.get("unique_hostname")
    if not cfg:
        log.info("no config for unique_hostname")
    else:
        role = cfg["role"]
        
        # connect to Route53 and retrieve the zone
        route53 = boto.connect_route53()
        
        ## this can fail if there's no network or if the system time is more
        ## than 5 minutes off Amazon's.  if it does, cloud-init.service will
        ## fail to start, which will interrupt the entire system startup.
        zone = boto.route53.zone.Zone(route53, route53.get_hosted_zone(cfg["route53_zone_id"]).HostedZone)
        
        # retrieve the instance ID and private IP address for this instance
        this_instance_id = _cloud.get_instance_id()
        local_ipv4 = _cloud.datasource.metadata.get("local-ipv4")
        
        # retrieve this instance so we can tag it
        region_id = _cloud.datasource.metadata.get("placement")["availability-zone"][:-1]
        ec2 = boto.ec2.connect_to_region(region_id)
        this_instance = ec2.get_only_instances([this_instance_id])[0]

        ## build hostname from role and instance id; this better be uniqueâ€¦
        hostname = "%s-%s" % (role, this_instance_id.split("-", 1)[1])

        # set the Name tag for this instance
        # @todo add environment suffix
        # "ec2:CreateTags"
        this_instance.add_tag("Name", hostname)

        # the fqdn is used when creating the A record in the zone.
        # drop trailing period; route53 doesn't need it and it's not
        # usually in /etc/hosts
        fqdn = ".".join((hostname, zone.name[:-1]))
        
        # just for diag
        log.info("hostname: %s, fqdn: %s", hostname, fqdn)
        
        # manage an /etc/hosts entry so 'hostname -f' works immediately.
        # otherwise we're at the mercy of the route53 update.
        hosts_entries = []
        with open("/etc/hosts") as ifp:
            for line in ifp.readlines():
                if hosts_entry_re.match(line):
                    hosts_entries.append(line.strip().split())
        
        buf = StringIO.StringIO()
        print >>buf, "%s %s %s" % (local_ipv4, fqdn, hostname)
        
        for hosts_entry in hosts_entries:
            # drop empty lines:
            if not hosts_entry:
                continue
            
            # drop existing entries for this host or ip
            if hosts_entry[0] == local_ipv4 or hosts_entry[1] == fqdn:
                continue
            
            print >>buf, "%s %s %s" % tuple(hosts_entry)
        
        util.write_file("/etc/hosts", buf.getvalue(), 0644)
        
        # set the hostname
        subprocess.check_call(["hostnamectl", "set-hostname", hostname])
        
        # create or update the A record.  again, defensive: this
        # probably won't ever be done more than once.
        # @todo move to a lambda function
        # @todo hrm, if using lambda, don't need to tag, here, either, now that
        # @todo we can build the hostname from known bits. so lambda means no
        # @todo route53, no ec2 tagging.  simpler implementation here. hopefully
        # @todo consistent for aws and gce!
        try:
            ## @todo retry
            rec = zone.get_a(fqdn)
            if rec:
                log.warning("'A' record for %s already exists", fqdn)
                
                # "route53:ChangeResourceRecordSets",
                resp = zone.update_a(fqdn, local_ipv4, ttl=30)
            else:
                # "route53:ChangeResourceRecordSets",
                resp = zone.add_a(fqdn, local_ipv4, ttl=30)
            
            log.info("'A' record update is %s", resp.update())
        except:
            # http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html
            # DNSServerError: DNSServerError: 400 Bad Request
            # <?xml version="1.0"?>
            # <ErrorResponse xmlns="https://route53.amazonaws.com/doc/2013-04-01/"><Error><Type>Sender</Type><Code>PriorRequestNotComplete</Code><Message>The request was rejected because Route 53 was still processing a prior request.</Message></Error><RequestId>09dfe283-378a-11e5-a04c-f76ca6216380</RequestId></ErrorResponse>

            log.error("unable to manage 'A' record for %s", fqdn, exc_info=True)
